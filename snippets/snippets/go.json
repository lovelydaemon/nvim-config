{
  "err != nil": {
    "prefix": "ern",
    "body": "err != nil $0",
    "description": "shortcut err != nil"
  },
  "for loop": {
    "prefix": "for",
    "body": [
      "for ${1:i} := ${2:0}; ${1:i} < ${3}; ${1:i}++ {",
      "\t$0",
      "}"
    ],
    "description": "for loop"
  },
  "for range": {
    "prefix": "forr",
    "body": [
      "for ${1:i}, ${2:v} := range ${3:arr} {",
      "\t$0",
      "}"
    ],
    "description": "for range"
  },
  "fmain": {
    "prefix": "fmain",
    "body": [
      "package main",
      "",
      "func main() {$0}"
    ],
    "description": "function main"
  },
  "http ResponseWriter *Request": {
    "prefix": "wr",
    "body": "${1:w} http.ResponseWriter, ${2:r} *http.Request$0",
    "description": "http handler declaration"
  },
  "xml struct tag": {
    "prefix": "xml-tag",
    "body": "`xml:\"$0\"`",
    "description": "xml struct tag"
  },
  "json struct tag": {
    "prefix": "json-tag",
    "body": "`json:\"$0\"`",
    "description": "json struct tag"
  },
  "env struct tag": {
    "prefix": "env-tag",
    "body": "`env:\"$0\"`",
    "description": "env struct tag"
  },
  "function receiver": {
    "prefix": "func-receiver",
    "body": "func ($1 *$2) $3($4) $5 {$0}",
    "description": "function receiver"
  },
  "test function": {
    "prefix": "func-test",
    "body": [
      "func Test$1 (t *testing.T) {",
      "\tt.Parallel()",
      "\t$0",
      "}"
    ],
    "description": "testing function template"
  },
  "table test": {
    "prefix": "table-test",
    "body": [
      "testCases := []struct {",
      "\tname  string",
      "\t$1",
      "}{",
      "\t{},",
      "}",
      "",
      "for _, tc := range testCases {",
      "\tt.Run(tc.name, func(t *testing.T) {",
      "\t\tt.Parallel()",
      "",
      "\t$2",
      "",
      "\t})",
      "}"
    ],
    "description": "table testing"
  },
  "benchmark function": {
    "prefix": "func-benchmark",
    "body": [
      "func Benchmark$1 (b *testing.B) {",
      "\tfor i := 0; i < b.N ; i++ {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "benchmark function template"
  },
  "assert func": {
    "prefix": "func-assert",
    "body": [
      "func assert$1(t testing.TB, ${2:got, want string}) {",
      "\tt.Helper()",
      "\tif got != want {",
      "\t\tt.Errorf(\"got ${3:%q} want ${4:%q}\", got, want)",
      "\t}",
      "}$0"
    ],
    "description": "assert helper function for want got"
  },
  "new struct": {
    "prefix": "new-struct",
    "body": [
      "type $1 struct {}",
      "",
      "func New$1() *$1 {",
      "\treturn &$1{}",
      "}",
      "",
      "func ($2 *$1) $3(ctx context.Context$4) $5 {$0}"
    ],
    "description": "struct constructor"
  },
  "command": {
    "prefix": "command",
    "body": [
      "package command",
      "",
      "import (",
      "\t\"context\"",
      ")",
      "",
      "type $1 struct {}",
      "",
      "type $1Handler struct {}",
      "",
      "func New$1Handler() *$1Handler {",
      "\treturn &$1Handler{}",
      "}",
      "",
      "func (h *$1Handler) Handle(ctx context.Context, cmd $1) ($2) {$0}"
    ],
    "description": "command handler constructor"
  },
  "controller": {
    "prefix": "controller",
    "body": [
      "type $1Controller struct {",
      "\tv *validator.Validate",
      "\t$2",
      "}",
      "",
      "func New$1Controller(router *chi.Mux, v *validator.Validate$3) {",
      "\tc := &$1Controller{",
      "\t\tv: v,",
      "\t}",
      "\t",
      "\trouter.Route(\"$4\", func(r chi.Router) {",
      "\t\t$5",
      "\t})",
      "}",
      "",
      "func (c *$1Controller) $6(w http.ResponseWriter, r *http.Request) {$0}"
    ],
    "description": "controller"
  },
  "ddd invalid error": {
    "prefix": "ddd-invalid-err",
    "body": [
      "type Invalid$1Error struct {",
      "\tValue string",
      "}",
      "",
      "func (e *Invalid$1Error) Error() string {",
      "\treturn fmt.Sprintf(\"invalid $2: %q\", e.Value)",
      "}"
    ],
    "description": "domain invalid error"
  },
  "ddd vo methods": {
    "prefix": "ddd-vo-methods",
    "body": [
      "func (vo $1) String() string {",
      "\treturn string(vo)",
      "}",
      "",
      "func (vo $1) Equals(other $1) bool {",
      "\treturn vo == other",
      "}",
      "",
      "func (vo $1) IsZero() bool {",
      "\treturn vo == \"\"",
      "}"
    ],
    "description": "domain value object methods"
  },
  "ddd value object": {
    "prefix": "ddd-vo",
    "body": [
      "package domain",
      "",
      "import \"fmt\"",
      "",
      "type Invalid$1Error struct {",
      "\tValue string",
      "}",
      "",
      "func (e *Invalid$1Error) Error() string {",
      "\treturn fmt.Sprintf(\"invalid $2: %q\", e.Value)",
      "}",
      "",
      "type $1 string",
      "",
      "const (",
      "\t$3",
      ")",
      "",
      "func Parse$1(s string) ($1, error) {",
      "\tswitch s {",
      "\tcase $4:",
      "\t\treturn $1(s), nil",
      "}",
      "",
      "\treturn \"\", &Invalid$1Error{s}",
      "}",
      "",
      "func (vo $1) String() string {",
      "\treturn string(vo)",
      "}",
      "",
      "func (vo $1) Equals(other $1) bool {",
      "\treturn vo == other",
      "}",
      "",
      "func (vo $1) IsZero() bool {",
      "\treturn vo == \"\"",
      "}"
    ],
    "description": "ddd value object"
  },
  "squirrel select": {
    "prefix": "builder-select",
    "body": [
      "qb := r.Builder.",
      "\tSelect($1).",
      "\tFrom($2).",
      "\tOrderBy($3)",
      "",
      "query, args, err := qb.ToSql()",
      "if err != nil {",
      "\treturn nil, fmt.Errorf(\"build sql query: %w\", err)",
      "}"
    ],
    "description": "squirrel select builder"
  },
  "squirrel update": {
    "prefix": "builder-update",
    "body": [
      "qb := r.Builder.",
      "\tUpdate(\"$1\").",
      "\tSet(\"version\", newVersion).",
      "\tWhere(sq.Eq{\"id\": $2}).",
      "\tWhere(sq.Eq{\"version\": $3})",
      "",
      "\tquery, args, err := qb.ToSql()",
      "\tif err != nil {",
      "\t\treturn fmt.Errorf(\"build sql query: %w\", err)",
      "\t}"
    ],
    "description": "squirrel update builder"
  },
  "pgx scan rows": {
    "prefix": "scan-rows",
    "body": [
      "rows, err := conn.Query(ctx, query, args...)",
      "if err != nil {",
      "\treturn nil, fmt.Errorf(\"executing query: %w\", err)",
      "}",
      "defer rows.Close()",
      "",
      "var ${2:results} []*domain.${4:Type}",
      "",
      "for rows.Next() {",
      "\tvar row ${5:RowStruct}",
      "",
      "\terr := rows.Scan($0)",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"scanning rows: %w\", err)",
      "\t}",
      "",
      "\t${3:domain}, err := row.ToDomain()",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"map row to domain: %w\", err)",
      "\t}",
      "",
      "\t${2:results} = append(${2:results}, ${3:domain})",
      "}",
      "",
      "if err := rows.Err(); err != nil {",
      "\treturn nil, fmt.Errorf(\"iterate rows: %w\", err)",
      "}",
      "",
      "return ${2:results}, nil"
    ],
    "description": "pgx scan rows"
  },
  "swagger docs": {
    "prefix": "swag-docs",
    "body": [
      "// @Summary ${1:Summary description}",
      "// @Description ${2:Full description of the route}",
      "// @ID ${3:Unique id}",
      "// @Tags ${4:Group name}",
      "// @Accept json",
      "// @Produce json",
      "// @Param ${5:param_name} ${6:where (query|path|body)} ${7:go_type} ${8:required (true/false)} \"${9:description}\"",
      "// @Success 200 {object} send.SuccessResponse{data=${10:response_type}}",
      "// @Failure 400 {object} send.AppError",
      "// @Failure 500 {object} send.AppError",
      "// @Router ${11:/route/} [${12:method (get|post|put|patch|delete)}]."
    ],
    "description": "swagger doc template"
  }
}
